Consul：服務注冊和發現 + 配置管理
https://developer.hashicorp.com/consul/docs
https://spring.io/projects/spring-cloud-consul

啓動: .\consul agent -dev

訪問: http://localhost:8500/ui/dc1/services

@Configuration
public class RestTemplateConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

因爲通過Consul去訪問微服務默認是支持負載的，所以必須在RestTemplate的Bean上添加@LoadBalanced ！！！！！！！！！！！！！！


配置管理:
       <!-- SpringCoud consul config-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-config</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-bootstrap</artifactId>
        </dependency>


#application.yml使用戶級別的資源配置項
#bootstrap.yml 是系統級別的，優先級別更高,比application.yml先加載

Spring Cloud 會先創建要給Bootstrap Context, 作爲Spring應用的 Application Context的父上下文。
初始化的時候，Bootstrap Context負責從外部源加載配置屬性(例如Consul中的全局配置!!!!!)，并且解析配置。這兩個上下文共享一個外部獲得的Environment


在主啓動類上添加: @RefreshScope 實現Consul中更新后，應用中立刻自動更新

Consul數據持久化:
    入駐windows後臺服務，儅windows啓動，就會自動啓動consul

    @echo.服務啟動......
    @echo off
    @sc create Consul binpath= "D:\consul\consul.exe agent -server -ui -bind=127.0.0.1 -client=0.0.0.0 -bootstrap-expect 1 -data-dir \"D:\consul\mydata\""
    @sc config Consul start= AUTO
    @net start Consul
    @echo.Consul start is OK......success
    @pause



用Docker來啓動!!!!!!!!!!!!!!!!!!!!!!!!!!!

docker volume create consul-data  建一個 Docker 自己管理的 volume（用來持久化）
docker rm -f consul-dev
docker run -d --name consul-dev -p 8500:8500 -p 8600:8600/udp -v consul-data:/consul/data hashicorp/consul:1.22 agent -server -bootstrap-expect=1 -ui -client="0.0.0.0" -data-dir=/consul/data


使用DiscoveryClient來獲得Consul上所有的注冊服務實例

spring:
  application:
    name: nitere-cloud-order

  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
      config:
        profile-separator: '-' #default value is ",", we update ‘_’
        format: YAML

    openfeign:
      client:
        config:
          #default: 為全局配置
          #nitere-cloud-production : 為指定服務進行配置
          default:
            #連接超時時間
            connectTimeout: 3000
            #讀取超時時間
            readTimeout: 3000


重試機制: 默認關閉
        通過新增配置類feignConfig


httpClient修改: 默認使用HttpURLConnection,  使用Apache HttpClient5來替換
        <!-- httpclient5 -->
        <dependency>
            <groupId>org.apache.httpcomponents.client5</groupId>
            <artifactId>httpclient5</artifactId>
            <version>5.4.4</version>
        </dependency>

        <dependency>
            <groupId>io.github.openfeign</groupId>
            <artifactId>feign-hc5</artifactId>
            <version>13.1</version>
        </dependency>


spring:
  application:
    name: nitere-cloud-order

  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
      config:
        profile-separator: '-' #default value is ",", we update ‘_’
        format: YAML

    openfeign:
      client:
        config:
          #default: 為全局配置
          #nitere-cloud-production : 為指定服務進行配置
          default:
            #連接超時時間
            connectTimeout: 4000
            #讀取超時時間
            readTimeout: 4000

      httpclient:
        hc5:
          enabled: true

壓縮: GZIP
spring:
  application:
    name: nitere-cloud-order

  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
      config:
        profile-separator: '-' #default value is ",", we update ‘_’
        format: YAML

    openfeign:
      client:
        config:
          #default: 為全局配置
          #nitere-cloud-production : 為指定服務進行配置
          default:
            #連接超時時間
            connectTimeout: 4000
            #讀取超時時間
            readTimeout: 4000

      httpclient:
        hc5:
          enabled: true
      compression:
        request:
          enabled: true
          min-request-size: 2048 # 最小出發壓縮的大小
          mime-types: text/xml,application/xml,application/json #觸發法索數據類型
        response:
          enabled: true

日志打印功能: 通過調整日志級別

1. 開啓日志
    @Bean
    Logger.Level feignLoggerlevel() {
        return Logger.Level.FULL;
    }

2.yml文件開啓日志客戶端

--------------------------------------------微服務之間的調用--------------------------------------------------------------------------------------------

loadBalancer： 負載均衡

@Configuration
public class RestTemplateConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

OpenFeign： 服務調用

 1. 超時控制: yml 文件中開啓配置: connectTimeout     readTimeout


----------------------------------------------------Resilience4j------------------------------------------------------------------------------

Circuit Breaker：服務熔斷和降級  Resilience4j: CLOSED | OPEN | HALF_OPEN


failure-rate-threshold:  以百分比配置失敗率峰值

sliding-window-type: 滑動窗口期類型 COUNT_BASE(基於次數) | TIME_BASED(基於時間)

sliding-window-size：
       COUNT_BASED: 10次調用中有50%失敗，打開熔斷器
       TIME_BASED： 在sliding-window-size秒内，100% show-call-rate-threshold的請求超過
       slow-call-duration-threshold, 打開熔斷器

如果配置為TIME_BASED:
show-call-rate-threshold: 以百分比方式配置，斷路器把調用時間大於 slow-call-duration-threshold的調用視爲慢調用
                           儅慢調用大於等於峰值，斷路器開啓，并且進入服務降級

slow-call-duration-threshold：配置調用時間峰值，高於該峰值的視爲慢調用. 例如3秒


permitted-number-of-calls-in-half-open-state: 斷路器在HALF_OPEN狀態下進行的調用次數，如果慢調用依然高於峰值，再次打開

minimum-number-of-calls: 滑動窗口樣本數，低於樣本，斷路器配置無效

wait-duration-in-open-state: 從OPEN到HALF_OPEN狀態等待的時間

*****************************************************************************
案例：
   6次訪問中，如果失敗率達到50%， CircuitBreaker 將進入OPEN
   5秒之後，CircuitBreaker從OPEN->HALF_OPEN， 進入服務降級fallback
   如果依然是異常，CircuitBreaker 將進入OPEN，否則進入CLOSED

********************************************************************************
   1. 服務熔斷:  close 可以正常使用，  open 拒絕訪問

   2.服務降級:

   3.服務限流:RateLimiter

     【限流算法】：
        漏斗算法(Leaky Bucket): 缺少效率

        令牌桶算法(Token Bucket) 【重點!!!!】:

        滾動時間窗口(tumbling time window) : 臨界時間點如果收到大量請求，容易引發系統奔潰

         滾動時間窗口(sliding time window)

       <!-- resilience4j-ratelimiter 限流算法-->
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-ratelimiter</artifactId>
        </dependency>

   4.服務限時:

   5.服務預熱:

   6.接近實時的監控:

   7.兜底的處理動作:

 bulkhead: 【艙壁隔離機制: 限制并發執行的數量！！！！！！！！！！！！！！！！！！！！！！！！！！！！】

    1. SemaphoreBulkhead: 信號量
         <!-- resilience4j-bulkhead 限流-->
                <dependency>
                    <groupId>io.github.resilience4j</groupId>
                    <artifactId>resilience4j-bulkhead</artifactId>
                </dependency>
         yml:
             maxConcurrentCalls: 艙壁容許的最大并發執行量
             maxWaitDuration:    嘗試進入飽和艙壁時，阻塞綫程等待的最長時間


    2. FixedThreadPoolBulkhead: 有界隊列和固定大小綫程池 通過核心綫程數、阻塞隊列

    【ThreadPoolBulkhead只對CompletableFuture方法有效，所以必須創建返回CompletableFuture類型的方法】




***********************************************************************************************
RateLimiter（限流）

关注：单位时间内允许多少请求通过

目的：防止突发流量把你或下游打爆

典型场景：

你要给某个下游 API 做“每秒最多 N 次调用”

你有明确的 SLA/配额（比如第三方接口）

Bulkhead（舱壁/并发隔离）

关注：同一时刻最多允许多少并发请求

目的：防止线程/连接被占满，把整个服务拖死

典型场景：

下游变慢导致请求堆积

你想限制某类调用最多占用多少资源

*********************************************************************************************************

调参优先级（nitere-cloud-order 实战顺序）

先定 Feign 超时（避免无限慢）

再定 Bulkhead 并发上限（防线程/资源被占满）

最后定 RateLimiter 速率（压尖峰、保护下游）

再微调 CircuitBreaker 的窗口/阈值

一个很好用的小经验值

在 nitere-cloud-order 里你可以用这个启发式：

maxConcurrentCalls
≈ 你愿意让这个下游调用最多占你服务多少资源
通常 20~50 是个安全区间（内部服务）

limitForPeriod
≈ maxConcurrentCalls * (1000ms / 下游平均耗时ms)
例如下游平均 100ms：

并发 30 → 粗略可承受 300 req/s
你可以先保守配 50~100/s，再看监控放大。

**********************************************************************************************************

Micrometer Tracing: 分佈式鏈路系統圖形工具。服務鏈路追蹤
   Distributed Tracing  分佈式鏈路追蹤 TraceId唯一標識 + Span ID每一次請求,通過 (Parent ID)關聯
   zipkin  展現 https://zipkin.io

   下載: iodocker run -d -p 9411:9411 openzipkin/zipkin


       <!-- micrometer-tracing 指標追蹤 2-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing</artifactId>
        </dependency>

        <!-- micrometer-tracing-bridge-brave適配zipkin的橋接包 3-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing-bridge-brave</artifactId>
        </dependency>

        <!-- micrometer-observation 4-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-observation</artifactId>
        </dependency>

        <!-- feign-micrometer 5-->
        <dependency>
            <groupId>io.github.openfeign</groupId>
            <artifactId>feign-micrometer</artifactId>
        </dependency>

        <!-- zipkin-reporter-brave 6-->
        <dependency>
            <groupId>io.zipkin.reporter2</groupId>
            <artifactId>zipkin-reporter-brave</artifactId>
            <version>${zipkin-reporter.version}</version>
        </dependency>


http://localhost:9411/
**********************************************************************************************************
Gateway: 服務網關  本身也是微服務，需要注冊進服務注冊中心
         客戶端向Spring cloud Gateway發出請求，在Gateway Handler Mapping中找到于請求匹配的路由，發送到Gateway Web Handler, 再通過
         指定的過濾器來將請求發送到實際的服務，最後返回

         在PRE類型的過濾器中可以做參數校驗、權限校驗、流浪監控、日志輸出、協議轉換
         在POST的過濾器中可以做響應内容、響應頭的修改，日志輸出，流量監控

   DispatcherHandler: 分發請求

   RoutePredicate-HandlerMapping: 路由查找

   FilteringWebHandler: 過濾器鏈，代理服務處理

 【3大核心概念】

   Route: 由ID，目標URI，一系列的斷言和過濾器組成，如果斷言為true則匹配該路由


   Predicate:


   Filter: